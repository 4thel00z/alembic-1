import itertools
import re
from mako.pygen import PythonPrinter

from ..util.compat import StringIO

from .render import _drop_table, _drop_column, _drop_index, _drop_constraint, \
    _add_table, _add_column, _add_index, _add_constraint, _modify_col, \
    _add_fk_constraint


def _render_diffs(diffs, autogen_context, template_args):
    opts = autogen_context['opts']
    imports = autogen_context['imports']
    template_args[opts['upgrade_token']] = _indent(_render_cmd_body(
        _produce_upgrade_commands, diffs, autogen_context))
    template_args[opts['downgrade_token']] = _indent(_render_cmd_body(
        _produce_downgrade_commands, diffs, autogen_context))
    template_args['imports'] = "\n".join(sorted(imports))


def _indent(text):
    text = re.compile(r'^', re.M).sub("    ", text).strip()
    text = re.compile(r' +$', re.M).sub("", text)
    return text


def _render_cmd_body(fn, diffs, autogen_context):

    buf = StringIO()
    printer = PythonPrinter(buf)

    printer.writeline(
        "### commands auto generated by Alembic - "
        "please adjust! ###"
    )

    for line in fn(diffs, autogen_context):
        printer.writeline(line)

    printer.writeline("### end Alembic commands ###")

    return buf.getvalue()


def _produce_upgrade_commands(diffs, autogen_context):
    return _produce_commands("upgrade", diffs, autogen_context)


def _produce_downgrade_commands(diffs, autogen_context):
    return _produce_commands("downgrade", diffs, autogen_context)


def _produce_commands(type_, diffs, autogen_context):
    opts = autogen_context['opts']
    render_as_batch = opts.get('render_as_batch', False)

    if diffs:
        if type_ == 'downgrade':
            diffs = reversed(diffs)
        for (schema, table), subdiffs in _group_diffs_by_table(diffs):
            if table is not None and render_as_batch:
                yield "with op.batch_alter_table"\
                    "(%r, schema=%r) as batch_op:" % (table, schema)
                autogen_context['batch_prefix'] = 'batch_op.'
            for diff in subdiffs:
                yield _invoke_command(type_, diff, autogen_context)
            if table is not None and render_as_batch:
                del autogen_context['batch_prefix']
                yield ""
    else:
        yield "pass"


def _invoke_command(updown, args, autogen_context):
    if isinstance(args, tuple):
        return _invoke_adddrop_command(updown, args, autogen_context)
    else:
        return _invoke_modify_command(updown, args, autogen_context)


def _invoke_adddrop_command(updown, args, autogen_context):
    cmd_type = args[0]
    adddrop, cmd_type = cmd_type.split("_")

    cmd_args = args[1:] + (autogen_context,)

    _commands = {
        "table": (_drop_table, _add_table),
        "column": (_drop_column, _add_column),
        "index": (_drop_index, _add_index),
        "constraint": (_drop_constraint, _add_constraint),
        "fk": (_drop_constraint, _add_fk_constraint)
    }

    cmd_callables = _commands[cmd_type]

    if (
        updown == "upgrade" and adddrop == "add"
    ) or (
        updown == "downgrade" and adddrop == "remove"
    ):
        return cmd_callables[1](*cmd_args)
    else:
        return cmd_callables[0](*cmd_args)


def _invoke_modify_command(updown, args, autogen_context):
    sname, tname, cname = args[0][1:4]
    kw = {}

    _arg_struct = {
        "modify_type": ("existing_type", "type_"),
        "modify_nullable": ("existing_nullable", "nullable"),
        "modify_default": ("existing_server_default", "server_default"),
    }
    for diff in args:
        diff_kw = diff[4]
        for arg in ("existing_type",
                    "existing_nullable",
                    "existing_server_default"):
            if arg in diff_kw:
                kw.setdefault(arg, diff_kw[arg])
        old_kw, new_kw = _arg_struct[diff[0]]
        if updown == "upgrade":
            kw[new_kw] = diff[-1]
            kw[old_kw] = diff[-2]
        else:
            kw[new_kw] = diff[-2]
            kw[old_kw] = diff[-1]

    if "nullable" in kw:
        kw.pop("existing_nullable", None)
    if "server_default" in kw:
        kw.pop("existing_server_default", None)
    return _modify_col(tname, cname, autogen_context, schema=sname, **kw)


def _group_diffs_by_table(diffs):
    _adddrop = {
        "table": lambda diff: (None, None),
        "column": lambda diff: (diff[0], diff[1]),
        "index": lambda diff: (diff[0].table.schema, diff[0].table.name),
        "constraint": lambda diff: (diff[0].table.schema, diff[0].table.name),
        "fk": lambda diff: (diff[0].parent.schema, diff[0].parent.name)
    }

    def _derive_table(diff):
        if isinstance(diff, tuple):
            cmd_type = diff[0]
            adddrop, cmd_type = cmd_type.split("_")
            return _adddrop[cmd_type](diff[1:])
        else:
            sname, tname = diff[0][1:3]
            return sname, tname

    return itertools.groupby(diffs, _derive_table)
